{% extends 'base.html' %}
{% load static %}

{% block title %}Optimizador de Rutas{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/optimizer.css' %}">
<style>
    .optimizer-card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        padding: 1.5rem;
        margin-bottom: 1rem;
    }
    
    .optimizer-header {
        border-bottom: 2px solid #e5e7eb;
        padding-bottom: 1rem;
        margin-bottom: 1.5rem;
    }
    
    .delivery-item {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.75rem;
        transition: all 0.2s ease;
    }
    
    .delivery-item:hover {
        background: #e2e8f0;
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .delivery-order {
        background: #3b82f6;
        color: white;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 1rem;
        flex-shrink: 0;
    }
    
    .delivery-info {
        flex: 1;
    }
    
    .delivery-client {
        font-weight: 600;
        color: #1f2937;
        margin-bottom: 0.25rem;
    }
    
    .delivery-address {
        color: #6b7280;
        font-size: 0.9rem;
        margin-bottom: 0.25rem;
    }
    
    .delivery-details {
        font-size: 0.85rem;
        color: #9ca3af;
    }
    
    .delivery-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }
    
    .btn-maps {
        background: #10b981;
        border-color: #10b981;
        color: white;
        font-size: 0.85rem;
        padding: 0.375rem 0.75rem;
    }
    
    .btn-maps:hover {
        background: #059669;
        border-color: #059669;
        color: white;
    }
    
    .optimizer-actions {
        display: flex;
        gap: 0.75rem;
        align-items: center;
    }
    
    .stats-card {
        text-align: center;
        padding: 1rem;
        background: #f8fafc;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
    }
    
    .stats-number {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
    }
    
    .no-entregas {
        text-align: center;
        padding: 3rem;
        color: #6b7280;
    }
    
    .alert-custom {
        padding: 1rem;
        margin-bottom: 1rem;
        border-radius: 8px;
        border-left: 4px solid;
    }
    
    .alert-info {
        background: #e0f2fe;
        border-left-color: #0288d1;
        color: #01579b;
    }
    
    .alert-warning {
        background: #fff3e0;
        border-left-color: #f57c00;
        color: #e65100;
    }
    
    .punto-salida-input {
        border: 2px solid #10b981;
        border-radius: 8px;
        padding: 0.75rem;
        font-size: 1rem;
    }
    
    .punto-salida-input:focus {
        border-color: #059669;
        box-shadow: 0 0 0 0.2rem rgba(16, 185, 129, 0.25);
    }
    
    .entrega-optimizada {
        border-left: 5px solid #10b981 !important;
        background: linear-gradient(90deg, #f0f9ff 0%, #ffffff 10%);
    }
    
    .orden-optimizado {
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        font-weight: bold;
        min-width: 35px;
        height: 35px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 1rem;
        box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
    }
    
    /* ‚≠ê ESTILOS PARA M√âTRICAS ‚≠ê */
    .metric-card {
        text-align: center;
        padding: 1rem;
        background: white;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        margin-bottom: 0.5rem;
    }
    
    .metric-number {
        font-size: 1.5rem;
        font-weight: bold;
        color: #1f2937;
        margin-bottom: 0.25rem;
    }
    
    .metric-label {
        font-size: 0.85rem;
        color: #6b7280;
        text-transform: uppercase;
        font-weight: 500;
    }
    
    #metricas-ruta {
        border-left: 4px solid #10b981;
        background: linear-gradient(90deg, #f0f9ff 0%, #ffffff 15%);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .delivery-eta {
        margin-top: 0.5rem;
    }
    
    .delivery-eta .text-success {
        font-weight: 600;
    }
    
    .metric-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
    }

    /* Configuraci√≥n de par√°metros */
    .config-section {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }

    .config-input {
        border: 1px solid #d1d5db;
        border-radius: 6px;
        padding: 0.5rem;
        font-size: 0.9rem;
        width: 100%;
    }

    .config-input:focus {
        border-color: #10b981;
        box-shadow: 0 0 0 0.1rem rgba(16, 185, 129, 0.25);
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="optimizer-card">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <div>
                        <h3 class="mb-1">
                            <i class="fas fa-route text-primary"></i>
                            Optimizador de Rutas con Estimaci√≥n de Tiempos
                        </h3>
                        <p class="text-muted mb-0">Gesti√≥n eficiente de entregas con c√°lculo de ETA y m√©tricas</p>
                    </div>
                    <div class="stats-card">
                        <div class="stats-number">{{ total_entregas }}</div>
                        <div>Entregas Programadas</div>
                    </div>
                </div>
                
                <!-- Panel de Control de Ruta -->
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="puntoSalida" class="form-label">
                                <i class="fas fa-map-marker-alt text-success"></i>
                                Punto de Salida
                            </label>
                            <input type="text" 
                                   id="puntoSalida" 
                                   class="form-control punto-salida-input"
                                   placeholder="Ej: Calle 80 #15-20, Bogot√°"
                                   value="Bodega Principal">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="horaInicio" class="form-label">
                                <i class="fas fa-clock text-info"></i>
                                Hora de Inicio
                            </label>
                            <input type="time" 
                                   id="horaInicio" 
                                   class="form-control"
                                   value="08:00">
                        </div>
                    </div>
                </div>

                <!-- Configuraci√≥n de Par√°metros -->
                <div class="config-section">
                    <h6><i class="fas fa-cog"></i> Configuraci√≥n de Par√°metros</h6>
                    <div class="row">
                        <div class="col-md-4">
                            <label class="form-label small">Velocidad (km/h)</label>
                            <input type="number" id="velocidadPromedio" class="config-input" value="25" min="10" max="60">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label small">Tiempo/Entrega (min)</label>
                            <input type="number" id="tiempoPorEntrega" class="config-input" value="15" min="5" max="60">
                        </div>
                        <div class="col-md-4">
                            <label class="form-label small">Hora de Inicio</label>
                            <input type="time" id="horaInicio" class="config-input" value="08:00">
                        </div>
                    </div>
                </div>
                
                <!-- Acciones de Optimizaci√≥n -->
                <div class="optimizer-actions">
                    <button type="button" 
                            class="btn btn-success btn-lg" 
                            onclick="optimizarRutaCompleta()">
                        <i class="fas fa-route"></i>
                        Optimizar Ruta
                    </button>
                    
                    <button type="button" 
                            class="btn btn-outline-info" 
                            onclick="mostrarOrdenOptimizado()">
                        <i class="fas fa-sort-numeric-down"></i>
                        Simular Orden
                    </button>
                    
                    <button type="button" 
                            class="btn btn-outline-primary" 
                            onclick="abrirTodasLasUbicaciones()">
                        <i class="fas fa-external-link-alt"></i>
                        Abrir Todas
                    </button>
                </div>
                
                <!-- Informaci√≥n de Ruta (inicialmente oculta) -->
                <div id="infoRuta" class="alert d-none mt-3">
                    <div id="textoInfoRuta"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Lista de Entregas -->
    <div class="row">
        <div class="col-12">
            <div class="optimizer-card">
                <h4 class="mb-3">
                    <i class="fas fa-truck text-success"></i>
                    Entregas Programadas
                </h4>
                
                {% if entregas %}
                    <div id="delivery-list">
                        {% for entrega in entregas %}
                        <div class="delivery-item d-flex align-items-center" 
                             data-enlace-maps="{{ entrega.pedido.cliente.enlace_maps }}">
                            <div class="delivery-order">{{ forloop.counter }}</div>
                            
                            <div class="delivery-info">
                                <div class="delivery-client">{{ entrega.pedido.cliente.nombre_completo }}</div>
                                <div class="delivery-address">
                                    <i class="fas fa-map-marker-alt text-muted"></i>
                                    {{ entrega.pedido.cliente.direccion|default:"Direcci√≥n no especificada" }}
                                </div>
                                <div class="delivery-details">
                                    Pedido #{{ entrega.numero }} ‚Ä¢ 
                                    Estado: {{ entrega.get_estado_display }}
                                </div>
                            </div>
                            
                            <div class="delivery-actions">
                                {% if entrega.pedido.cliente.enlace_maps %}
                                    <button type="button" 
                                            class="btn btn-maps btn-sm"
                                            onclick="abrirUbicacion('{{ entrega.pedido.cliente.enlace_maps }}', '{{ entrega.pedido.cliente.nombre_completo }}')">
                                        <i class="fas fa-map"></i>
                                        Abrir Maps
                                    </button>
                                {% else %}
                                    <span class="text-muted small">Sin GPS</span>
                                {% endif %}
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                {% else %}
                    <div class="no-entregas">
                        <i class="fas fa-truck fa-3x text-muted mb-3"></i>
                        <h5>No hay entregas programadas</h5>
                        <p class="text-muted">Programa algunas entregas para usar el optimizador de rutas.</p>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// ‚≠ê CONFIGURACI√ìN DIN√ÅMICA DE PAR√ÅMETROS ‚≠ê
function obtenerConfiguracion() {
    return {
        velocidadPromedio: parseFloat(document.getElementById('velocidadPromedio').value) || 25,
        tiempoPorEntrega: parseFloat(document.getElementById('tiempoPorEntrega').value) || 15,
        horaInicio: document.getElementById('horaInicio').value || '08:00'
    };
}

// Abrir ubicaci√≥n individual en Google Maps
function abrirUbicacion(enlaceMaps, cliente) {
    if (enlaceMaps && enlaceMaps.trim() !== '') {
        window.open(enlaceMaps, '_blank');
        mostrarAlerta('success', `Abriendo ubicaci√≥n de ${cliente} en Google Maps`);
    } else {
        mostrarAlerta('error', 'No se encontr√≥ la ubicaci√≥n de Google Maps para este cliente');
    }
}

// Funci√≥n principal de optimizaci√≥n con estimaci√≥n de tiempos (MEJORADA CON 2-OPT)
function optimizarRutaCompleta() {
    console.log('üöÄ Iniciando optimizaci√≥n avanzada de ruta con algoritmo 2-opt');
    
    const puntoSalida = document.getElementById('puntoSalida').value.trim();
    if (!puntoSalida) {
        mostrarAlerta('warning', 'Por favor ingrese el punto de salida');
        return;
    }
    
    const config = obtenerConfiguracion();
    console.log('‚öôÔ∏è Configuraci√≥n:', config);
    
    const entregas = document.querySelectorAll('.delivery-item');
    const ubicaciones = [];
    
    // Recopilar ubicaciones con enlaces de Maps
    entregas.forEach((entrega, index) => {
        const enlaceMaps = entrega.dataset.enlaceMaps;
        const cliente = entrega.querySelector('.delivery-client').textContent;
        
        if (enlaceMaps && enlaceMaps.trim() !== '') {
            const coords = extraerCoordenadas(enlaceMaps);
            if (coords && coords.includes(',')) {
                const [lat, lng] = coords.split(',').map(coord => parseFloat(coord.trim()));
                ubicaciones.push({
                    index: index + 1,
                    cliente: cliente,
                    enlace: enlaceMaps,
                    lat: lat,
                    lng: lng,
                    visitado: false
                });
            }
        }
    });
    
    console.log(`üìç Ubicaciones encontradas: ${ubicaciones.length}`);
    console.log(`üè† Punto de salida: ${puntoSalida}`);
    
    if (ubicaciones.length === 0) {
        mostrarAlerta('warning', 'No hay ubicaciones configuradas para optimizar');
        return;
    }
    
    // ‚≠ê NUEVA OPTIMIZACI√ìN AVANZADA ‚≠ê
    console.log('\nüöÄ ALGORITMO AVANZADO: VECINO M√ÅS CERCANO + 2-OPT');
    console.log('=' * 50);
    
    let ubicacionesOptimizadas;
    let algoritmUsado = '';
    
    if (ubicaciones.length >= 3) {
        // Para 3+ ubicaciones: usar m√∫ltiples puntos de inicio + 2-opt
        console.log('üéØ Aplicando optimizaci√≥n avanzada (m√∫ltiples intentos + 2-opt)');
        
        const resultado = optimizarConMultiplesPuntosInicio(ubicaciones, puntoSalida, 3);
        ubicacionesOptimizadas = resultado.ruta;
        algoritmUsado = resultado.algoritmo;
        
    } else {
        // Para 1-2 ubicaciones: algoritmo b√°sico
        console.log('üéØ Aplicando algoritmo b√°sico (pocas ubicaciones)');
        ubicacionesOptimizadas = optimizarOrdenEntregasBasico(ubicaciones, puntoSalida);
        algoritmUsado = 'Vecino m√°s cercano (optimizaci√≥n b√°sica)';
    }
    
    console.log(`\n‚úÖ Optimizaci√≥n completada con: ${algoritmUsado}`);
    
    // Calcular m√©tricas completas
    const puntoSalidaCoords = [4.6097, -74.0817]; // Coordenadas aproximadas de Bogot√°
    const bodegaCoords = [4.6533, -74.0625]; // Coordenadas de la bodega
    
    const metricas = calcularMetricasRuta(ubicacionesOptimizadas, puntoSalidaCoords, bodegaCoords, config);
    
    // Agregar informaci√≥n del algoritmo usado
    metricas.algoritmo = algoritmUsado;
    
    // Mostrar m√©tricas en la interfaz
    mostrarMetricasEnInterfaz(metricas);
    
    // Agregar ETA a cada entrega
    mostrarETAEnEntregas(metricas);
    
    // Crear URL de Google Maps con orden optimizado
    let urlMaps = 'https://www.google.com/maps/dir/';
    
    // Agregar punto de salida como origen
    urlMaps += encodeURIComponent(puntoSalida) + '/';
    
    // Agregar ubicaciones en orden optimizado
    ubicacionesOptimizadas.forEach((ubicacion, index) => {
        urlMaps += `${ubicacion.lat},${ubicacion.lng}`;
        if (index < ubicacionesOptimizadas.length - 1) {
            urlMaps += '/';
        }
    });
    
    // Agregar la BODEGA como destino final
    const bodegaUbicacion = 'Calle 94 #15-32, Bogot√°, Colombia';
    urlMaps += '/' + encodeURIComponent(bodegaUbicacion);
    
    // Agregar par√°metros de Google Maps
    urlMaps += '?travelmode=driving';
    
    console.log('üó∫Ô∏è URL optimizada:', urlMaps);
    console.log('üéØ Orden optimizado:', ubicacionesOptimizadas.map(u => u.cliente));
    
    // Mostrar el orden optimizado en la interfaz
    mostrarOrdenOptimizadoVisual(ubicacionesOptimizadas);
    
    // Mostrar informaci√≥n de la ruta actualizada con m√©tricas
    const infoRuta = document.getElementById('infoRuta');
    const textoInfo = document.getElementById('textoInfoRuta');
    
    if (infoRuta && textoInfo) {
        const ordenTexto = ubicacionesOptimizadas.map((u, i) => `${i+1}. ${u.cliente}`).join('<br>   ');
        
        textoInfo.innerHTML = `
            <strong>‚úÖ Ruta optimizada generada exitosamente:</strong><br>
            üìç <strong>Punto de salida:</strong> ${puntoSalida}<br>
            üéØ <strong>Orden optimizado:</strong><br>   ${ordenTexto}<br>
            üè† <strong>Destino final:</strong> BODEGA<br>
            üìä <strong>M√©tricas:</strong> ${metricas.resumen}<br>
            ‚ö° <strong>Algoritmo:</strong> ${algoritmUsado}
        `;
        
        infoRuta.className = 'alert alert-success';
        infoRuta.classList.remove('d-none');
    }
    
    // Abrir en Google Maps
    window.open(urlMaps, '_blank');
    
    mostrarAlerta('success', `üöÄ Ruta optimizada: ${puntoSalida} ‚Üí ${ubicacionesOptimizadas.length} entregas ‚Üí BODEGA ‚Ä¢ ${metricas.resumen}`);
}

// Algoritmo de optimizaci√≥n: Vecino m√°s cercano
function optimizarOrdenEntregas(ubicaciones, puntoSalida) {
    console.log('üß† Aplicando algoritmo de optimizaci√≥n...');
    
    // Coordenadas aproximadas del punto de salida (centro de Bogot√° por defecto)
    let currentLat = 4.6097;
    let currentLng = -74.0817;
    
    // Si el punto de salida es conocido, usar coordenadas espec√≠ficas
    if (puntoSalida.toLowerCase().includes('bodega') || puntoSalida.includes('94')) {
        currentLat = 4.6533;
        currentLng = -74.0625;
    }
    
    const ubicacionesCopia = [...ubicaciones];
    const ordenOptimizado = [];
    
    // Algoritmo del vecino m√°s cercano
    while (ubicacionesCopia.length > 0) {
        let menorDistancia = Infinity;
        let indiceProximo = 0;
        
        // Encontrar la ubicaci√≥n m√°s cercana
        ubicacionesCopia.forEach((ubicacion, index) => {
            const distancia = calcularDistancia(currentLat, currentLng, ubicacion.lat, ubicacion.lng);
            if (distancia < menorDistancia) {
                menorDistancia = distancia;
                indiceProximo = index;
            }
        });
        
        // Agregar la ubicaci√≥n m√°s cercana al orden optimizado
        const proximaUbicacion = ubicacionesCopia.splice(indiceProximo, 1)[0];
        ordenOptimizado.push(proximaUbicacion);
        
        // Actualizar posici√≥n actual
        currentLat = proximaUbicacion.lat;
        currentLng = proximaUbicacion.lng;
        
        console.log(`   ${ordenOptimizado.length}. ${proximaUbicacion.cliente} (distancia: ${menorDistancia.toFixed(2)} km)`);
    }
    
    console.log('‚úÖ Optimizaci√≥n completada');
    return ordenOptimizado;
}

// Calcular distancia entre dos puntos geogr√°ficos (f√≥rmula de Haversine simplificada)
function calcularDistancia(lat1, lng1, lat2, lng2) {
    const R = 6371; // Radio de la Tierra en km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
        Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c; // Distancia en km
}

// ‚≠ê ALGORITMO 2-OPT IMPROVEMENT ‚≠ê

// Calcular distancia total de una ruta completa
function calcularDistanciaTotal(ruta, puntoSalidaCoords, bodegaCoords) {
    if (ruta.length === 0) return 0;
    
    let distanciaTotal = 0;
    let currentLat = puntoSalidaCoords[0];
    let currentLng = puntoSalidaCoords[1];
    
    // Distancia desde punto de salida al primer destino
    distanciaTotal += calcularDistancia(currentLat, currentLng, ruta[0].lat, ruta[0].lng);
    
    // Distancias entre destinos consecutivos
    for (let i = 0; i < ruta.length - 1; i++) {
        distanciaTotal += calcularDistancia(ruta[i].lat, ruta[i].lng, ruta[i + 1].lat, ruta[i + 1].lng);
    }
    
    // Distancia desde √∫ltimo destino a la bodega
    const ultimoDestino = ruta[ruta.length - 1];
    distanciaTotal += calcularDistancia(ultimoDestino.lat, ultimoDestino.lng, bodegaCoords[0], bodegaCoords[1]);
    
    return distanciaTotal;
}

// ‚≠ê ALGORITMO 2-OPT MEJORADO ‚≠ê

// Intercambiar segmento en la ruta (operaci√≥n 2-opt optimizada)
function intercambiar2opt(ruta, i, j) {
    // Crear nueva ruta intercambiando el segmento entre i y j
    const nuevaRuta = [...ruta];
    
    // Invertir el segmento entre i y j (m√°s eficiente)
    while (i < j) {
        [nuevaRuta[i], nuevaRuta[j]] = [nuevaRuta[j], nuevaRuta[i]];
        i++;
        j--;
    }
    
    return nuevaRuta;
}

// Pre-verificaci√≥n para intercambios 2-opt (optimizaci√≥n)
function esIntercambioPromisorio(ruta, i, j, puntoSalidaCoords, bodegaCoords) {
    // Calcular solo las aristas que cambiar√≠an
    const n = ruta.length;
    
    // Coordenadas actuales
    let lat1, lng1, lat2, lng2, lat3, lng3, lat4, lng4;
    
    // Arista antes de i
    if (i === 0) {
        lat1 = puntoSalidaCoords[0];
        lng1 = puntoSalidaCoords[1];
    } else {
        lat1 = ruta[i-1].lat;
        lng1 = ruta[i-1].lng;
    }
    lat2 = ruta[i].lat;
    lng2 = ruta[i].lng;
    
    // Arista despu√©s de j
    lat3 = ruta[j].lat;
    lng3 = ruta[j].lng;
    if (j === n-1) {
        lat4 = bodegaCoords[0];
        lng4 = bodegaCoords[1];
    } else {
        lat4 = ruta[j+1].lat;
        lng4 = ruta[j+1].lng;
    }
    
    // Distancia actual de las aristas que cambiar√≠an
    const distanciaActual = calcularDistancia(lat1, lng1, lat2, lng2) + calcularDistancia(lat3, lng3, lat4, lng4);
    
    // Distancia nueva de las aristas que cambiar√≠an
    const distanciaNueva = calcularDistancia(lat1, lng1, lat3, lng3) + calcularDistancia(lat2, lng2, lat4, lng4);
    
    // Solo hacer el intercambio si promete una mejora
    return distanciaNueva < distanciaActual;
}

// Algoritmo 2-opt improvement (versi√≥n optimizada)
function optimizar2opt(rutaInicial, puntoSalidaCoords, bodegaCoords, maxIteraciones = 200) {
    console.log('üîÑ Aplicando mejora 2-opt avanzada...');
    
    if (rutaInicial.length < 3) {
        console.log('‚ö†Ô∏è Ruta muy peque√±a para 2-opt, manteniendo original');
        return rutaInicial;
    }
    
    let mejorRuta = [...rutaInicial];
    let mejorDistancia = calcularDistanciaTotal(mejorRuta, puntoSalidaCoords, bodegaCoords);
    let iteracion = 0;
    let mejorado = true;
    let mejoraSinCambio = 0;
    const maxSinCambio = 25; // Parar si no hay mejoras en 25 iteraciones
    
    console.log(`üìè Distancia inicial: ${mejorDistancia.toFixed(2)} km`);
    
    while (mejorado && iteracion < maxIteraciones && mejoraSinCambio < maxSinCambio) {
        mejorado = false;
        iteracion++;
        let mejorIteracion = false;
        
        // Probar todos los intercambios posibles de manera m√°s eficiente
        for (let i = 0; i < mejorRuta.length - 2; i++) {
            for (let j = i + 2; j < mejorRuta.length; j++) {
                // Verificar si vale la pena hacer el intercambio (pre-check)
                if (esIntercambioPromisorio(mejorRuta, i, j, puntoSalidaCoords, bodegaCoords)) {
                    // Crear nueva ruta con intercambio 2-opt
                    const nuevaRuta = intercambiar2opt(mejorRuta, i, j);
                    const nuevaDistancia = calcularDistanciaTotal(nuevaRuta, puntoSalidaCoords, bodegaCoords);
                    
                    // Si encontramos una mejora, actualizamos
                    if (nuevaDistancia < mejorDistancia) {
                        const mejora = mejorDistancia - nuevaDistancia;
                        mejorRuta = nuevaRuta;
                        mejorDistancia = nuevaDistancia;
                        mejorado = true;
                        mejorIteracion = true;
                        mejoraSinCambio = 0;
                        
                        console.log(`   üéØ Mejora en iteraci√≥n ${iteracion}: -${mejora.toFixed(2)} km ‚Üí ${nuevaDistancia.toFixed(2)} km`);
                        
                        // Si encontramos una mejora significativa, reiniciar desde el principio
                        if (mejora > 0.5) {
                            break;
                        }
                    }
                }
            }
            if (mejorIteracion && (mejorDistancia - calcularDistanciaTotal(rutaInicial, puntoSalidaCoords, bodegaCoords)) > 0.5) {
                break; // Salir del loop externo si hay mejora significativa
            }
        }
        
        if (!mejorIteracion) {
            mejoraSinCambio++;
        }
    }
    
    const ahorro = calcularDistanciaTotal(rutaInicial, puntoSalidaCoords, bodegaCoords) - mejorDistancia;
    const porcentajeAhorro = (ahorro / calcularDistanciaTotal(rutaInicial, puntoSalidaCoords, bodegaCoords)) * 100;
    
    console.log(`‚úÖ 2-opt completado en ${iteracion} iteraciones`);
    console.log(`üìâ Ahorro total: ${ahorro.toFixed(2)} km (${porcentajeAhorro.toFixed(1)}%)`);
    console.log(`üìè Distancia final: ${mejorDistancia.toFixed(2)} km`);
    
    return mejorRuta;
}

// ‚≠ê OPTIMIZACI√ìN MEJORADA CON PUNTO DE PARTIDA REAL ‚≠ê

// Optimizador avanzado con m√∫ltiples estrategias
function optimizarConMultiplesPuntosInicio(ubicaciones, puntoSalida, numIntentos = 5) {
    console.log(`ÔøΩ OPTIMIZACI√ìN AVANZADA DE RUTAS`);
    console.log(`üìç Punto de salida: ${puntoSalida}`);
    console.log(`ÔøΩüé≤ Probando ${numIntentos} estrategias diferentes...`);
    
    // Coordenadas del punto de salida (m√°s precisas)
    const puntoSalidaCoords = obtenerCoordenadasPuntoSalida(puntoSalida);
    const bodegaCoords = [4.6533, -74.0625]; // Bodega Central
    
    console.log(`üìç Coordenadas de salida: [${puntoSalidaCoords[0].toFixed(4)}, ${puntoSalidaCoords[1].toFixed(4)}]`);
    
    let mejorRuta = null;
    let mejorDistancia = Infinity;
    let mejorAlgoritmo = '';
    let todasLasRutas = [];
    
    // ESTRATEGIA 1: Vecino m√°s cercano desde punto de salida
    console.log(`\nüîÑ Estrategia 1: Vecino m√°s cercano puro`);
    const ruta1 = algoritmoVecinoMasCercanoMejorado(ubicaciones, puntoSalidaCoords);
    const ruta1Optimizada = optimizar2opt(ruta1, puntoSalidaCoords, bodegaCoords, 150);
    const distancia1 = calcularDistanciaTotal(ruta1Optimizada, puntoSalidaCoords, bodegaCoords);
    
    todasLasRutas.push({
        ruta: ruta1Optimizada,
        distancia: distancia1,
        algoritmo: 'Vecino m√°s cercano + 2-opt'
    });
    
    // ESTRATEGIA 2: Ordenamiento por sectores geogr√°ficos
    console.log(`\nüîÑ Estrategia 2: Ordenamiento por sectores`);
    const ruta2 = algoritmoSectoresGeograficos(ubicaciones, puntoSalidaCoords);
    const ruta2Optimizada = optimizar2opt(ruta2, puntoSalidaCoords, bodegaCoords, 150);
    const distancia2 = calcularDistanciaTotal(ruta2Optimizada, puntoSalidaCoords, bodegaCoords);
    
    todasLasRutas.push({
        ruta: ruta2Optimizada,
        distancia: distancia2,
        algoritmo: 'Sectores geogr√°ficos + 2-opt'
    });
    
    // ESTRATEGIA 3: Diferentes puntos de inicio
    for (let intento = 1; intento <= numIntentos - 2; intento++) {
        console.log(`\nüîÑ Estrategia ${intento + 2}: Inicio aleatorio ${intento}`);
        
        const ubicacionesCopia = [...ubicaciones];
        
        // Comenzar desde ubicaci√≥n aleatoria
        const indiceAleatorio = Math.floor(Math.random() * ubicacionesCopia.length);
        const ubicacionInicial = ubicacionesCopia.splice(indiceAleatorio, 1)[0];
        
        // Construir ruta desde esa ubicaci√≥n
        const rutaDesdeAleatorio = construirRutaDesdeUbicacion(ubicacionInicial, ubicacionesCopia, puntoSalidaCoords);
        const rutaAleatoria = optimizar2opt(rutaDesdeAleatorio, puntoSalidaCoords, bodegaCoords, 150);
        const distanciaAleatoria = calcularDistanciaTotal(rutaAleatoria, puntoSalidaCoords, bodegaCoords);
        
        todasLasRutas.push({
            ruta: rutaAleatoria,
            distancia: distanciaAleatoria,
            algoritmo: `Inicio aleatorio ${intento} + 2-opt`
        });
    }
    
    // Encontrar la mejor ruta
    todasLasRutas.forEach((resultado, index) => {
        console.log(`   üìè ${resultado.algoritmo}: ${resultado.distancia.toFixed(2)} km`);
        
        if (resultado.distancia < mejorDistancia) {
            mejorRuta = resultado.ruta;
            mejorDistancia = resultado.distancia;
            mejorAlgoritmo = resultado.algoritmo;
            console.log(`   üèÜ ¬°Nueva mejor soluci√≥n!`);
        }
    });
    
    // Calcular estad√≠sticas
    const distancias = todasLasRutas.map(r => r.distancia);
    const peorDistancia = Math.max(...distancias);
    const promedioDistancia = distancias.reduce((a, b) => a + b, 0) / distancias.length;
    const mejoramiento = ((peorDistancia - mejorDistancia) / peorDistancia * 100);
    
    console.log(`\nüéâ RESULTADO FINAL:`);
    console.log(`   üèÜ Mejor: ${mejorDistancia.toFixed(2)} km (${mejorAlgoritmo})`);
    console.log(`   üìä Promedio: ${promedioDistancia.toFixed(2)} km`);
    console.log(`   üìà Mejora vs peor: ${mejoramiento.toFixed(1)}%`);
    
    return {
        ruta: mejorRuta,
        distancia: mejorDistancia,
        algoritmo: mejorAlgoritmo
    };
}

// Obtener coordenadas precisas del punto de salida
function obtenerCoordenadasPuntoSalida(puntoSalida) {
    // Coordenadas m√°s precisas seg√∫n el punto de salida
    const puntosConocidos = {
        'bodega': [4.6533, -74.0625],
        'centro': [4.5981, -74.0758],
        'chapinero': [4.6700, -74.0600],
        'zona rosa': [4.6700, -74.0600],
        'suba': [4.7500, -74.0900],
        'kennedy': [4.5900, -74.1400],
        'engativa': [4.6800, -74.1200],
        'fontibon': [4.6700, -74.1300]
    };
    
    const puntoLower = puntoSalida.toLowerCase();
    
    for (const [nombre, coords] of Object.entries(puntosConocidos)) {
        if (puntoLower.includes(nombre)) {
            return coords;
        }
    }
    
    // Default: Centro de Bogot√°
    return [4.6097, -74.0817];
}

// Algoritmo vecino m√°s cercano mejorado
function algoritmoVecinoMasCercanoMejorado(ubicaciones, puntoSalidaCoords) {
    const ubicacionesCopia = [...ubicaciones];
    const rutaOptimizada = [];
    let currentLat = puntoSalidaCoords[0];
    let currentLng = puntoSalidaCoords[1];
    
    console.log(`   üìç Iniciando desde [${currentLat.toFixed(4)}, ${currentLng.toFixed(4)}]`);
    
    while (ubicacionesCopia.length > 0) {
        let menorDistancia = Infinity;
        let indiceProximo = 0;
        
        ubicacionesCopia.forEach((ubicacion, index) => {
            const distancia = calcularDistancia(currentLat, currentLng, ubicacion.lat, ubicacion.lng);
            if (distancia < menorDistancia) {
                menorDistancia = distancia;
                indiceProximo = index;
            }
        });
        
        const proximaUbicacion = ubicacionesCopia.splice(indiceProximo, 1)[0];
        rutaOptimizada.push(proximaUbicacion);
        
        console.log(`   ‚ûú ${rutaOptimizada.length}. ${proximaUbicacion.cliente} (${menorDistancia.toFixed(2)} km)`);
        
        currentLat = proximaUbicacion.lat;
        currentLng = proximaUbicacion.lng;
    }
    
    return rutaOptimizada;
}

// Algoritmo por sectores geogr√°ficos
function algoritmoSectoresGeograficos(ubicaciones, puntoSalidaCoords) {
    console.log(`   üó∫Ô∏è Organizando por sectores geogr√°ficos...`);
    
    // Definir sectores de Bogot√°
    const sectores = {
        'norte': [],      // Suba, Usaqu√©n
        'centro': [],     // Chapinero, Centro
        'sur': [],        // Kennedy, Bosa
        'occidente': [],  // Fontib√≥n, Engativ√°
        'oriente': []     // San Crist√≥bal, etc.
    };
    
    // Clasificar ubicaciones por sector
    ubicaciones.forEach(ubicacion => {
        const lat = ubicacion.lat;
        const lng = ubicacion.lng;
        
        if (lat > 4.68) {
            sectores.norte.push(ubicacion);
        } else if (lat > 4.62) {
            sectores.centro.push(ubicacion);
        } else if (lat < 4.60) {
            sectores.sur.push(ubicacion);
        } else if (lng < -74.10) {
            sectores.occidente.push(ubicacion);
        } else {
            sectores.oriente.push(ubicacion);
        }
    });
    
    // Ordenar sectores por proximidad al punto de salida
    const sectoresOrdenados = [];
    const pSLat = puntoSalidaCoords[0];
    const pSLng = puntoSalidaCoords[1];
    
    Object.entries(sectores).forEach(([nombre, ubicacionesSector]) => {
        if (ubicacionesSector.length > 0) {
            // Calcular distancia promedio del sector al punto de salida
            const distanciaPromedio = ubicacionesSector.reduce((sum, ub) => {
                return sum + calcularDistancia(pSLat, pSLng, ub.lat, ub.lng);
            }, 0) / ubicacionesSector.length;
            
            sectoresOrdenados.push({
                nombre,
                ubicaciones: ubicacionesSector,
                distanciaPromedio
            });
        }
    });
    
    // Ordenar sectores por proximidad
    sectoresOrdenados.sort((a, b) => a.distanciaPromedio - b.distanciaPromedio);
    
    // Construir ruta visitando sectores en orden
    const rutaPorSectores = [];
    let currentLat = pSLat;
    let currentLng = pSLng;
    
    sectoresOrdenados.forEach(sector => {
        console.log(`   üìç Sector ${sector.nombre}: ${sector.ubicaciones.length} entregas`);
        
        // Optimizar orden dentro del sector
        const ubicacionesSector = [...sector.ubicaciones];
        while (ubicacionesSector.length > 0) {
            let menorDistancia = Infinity;
            let indiceProximo = 0;
            
            ubicacionesSector.forEach((ubicacion, index) => {
                const distancia = calcularDistancia(currentLat, currentLng, ubicacion.lat, ubicacion.lng);
                if (distancia < menorDistancia) {
                    menorDistancia = distancia;
                    indiceProximo = index;
                }
            });
            
            const proximaUbicacion = ubicacionesSector.splice(indiceProximo, 1)[0];
            rutaPorSectores.push(proximaUbicacion);
            
            currentLat = proximaUbicacion.lat;
            currentLng = proximaUbicacion.lng;
        }
    });
    
    return rutaPorSectores;
}

// Construir ruta desde ubicaci√≥n espec√≠fica
function construirRutaDesdeUbicacion(ubicacionInicial, restanteUbicaciones, puntoSalidaCoords) {
    const ruta = [ubicacionInicial];
    const ubicacionesPendientes = [...restanteUbicaciones];
    
    let currentLat = ubicacionInicial.lat;
    let currentLng = ubicacionInicial.lng;
    
    while (ubicacionesPendientes.length > 0) {
        let menorDistancia = Infinity;
        let indiceProximo = 0;
        
        ubicacionesPendientes.forEach((ubicacion, index) => {
            const distancia = calcularDistancia(currentLat, currentLng, ubicacion.lat, ubicacion.lng);
            if (distancia < menorDistancia) {
                menorDistancia = distancia;
                indiceProximo = index;
            }
        });
        
        const proximaUbicacion = ubicacionesPendientes.splice(indiceProximo, 1)[0];
        ruta.push(proximaUbicacion);
        
        currentLat = proximaUbicacion.lat;
        currentLng = proximaUbicacion.lng;
    }
    
    return ruta;
}

// Versi√≥n b√°sica del vecino m√°s cercano (sin logging excesivo)
function optimizarOrdenEntregasBasico(ubicaciones, puntoSalida) {
    // Coordenadas aproximadas del punto de salida
    let currentLat = 4.6097;
    let currentLng = -74.0817;
    
    if (puntoSalida.toLowerCase().includes('bodega') || puntoSalida.includes('94')) {
        currentLat = 4.6533;
        currentLng = -74.0625;
    }
    
    const ubicacionesCopia = [...ubicaciones];
    const ordenOptimizado = [];
    
    // Algoritmo del vecino m√°s cercano
    while (ubicacionesCopia.length > 0) {
        let menorDistancia = Infinity;
        let indiceProximo = 0;
        
        ubicacionesCopia.forEach((ubicacion, index) => {
            const distancia = calcularDistancia(currentLat, currentLng, ubicacion.lat, ubicacion.lng);
            if (distancia < menorDistancia) {
                menorDistancia = distancia;
                indiceProximo = index;
            }
        });
        
        const proximaUbicacion = ubicacionesCopia.splice(indiceProximo, 1)[0];
        ordenOptimizado.push(proximaUbicacion);
        
        currentLat = proximaUbicacion.lat;
        currentLng = proximaUbicacion.lng;
    }
    
    return ordenOptimizado;
}

// ‚≠ê FUNCIONES DE ESTIMACI√ìN DE TIEMPO Y M√âTRICAS ‚≠ê

// Calcular m√©tricas completas de la ruta
function calcularMetricasRuta(ubicacionesOptimizadas, puntoSalidaCoords, bodegaCoords, config) {
    console.log('üìä Calculando m√©tricas de la ruta...');
    
    let distanciaTotal = 0;
    let tiempoTotal = 0; // en minutos
    let currentLat = puntoSalidaCoords[0];
    let currentLng = puntoSalidaCoords[1];
    
    const metricas = {
        entregas: [],
        distanciaTotal: 0,
        tiempoTotal: 0,
        tiempoConduccion: 0,
        tiempoEntregas: 0,
        horaFinEstimada: '',
        resumen: ''
    };
    
    // Calcular para cada entrega
    ubicacionesOptimizadas.forEach((ubicacion, index) => {
        const distanciaTramo = calcularDistancia(currentLat, currentLng, ubicacion.lat, ubicacion.lng);
        const tiempoTramo = (distanciaTramo / config.velocidadPromedio) * 60; // minutos
        
        distanciaTotal += distanciaTramo;
        tiempoTotal += tiempoTramo + config.tiempoPorEntrega;
        
        // Calcular ETA para esta entrega
        const etaMinutos = tiempoTotal;
        const horaETA = calcularHoraETA(config.horaInicio, etaMinutos);
        
        metricas.entregas.push({
            orden: index + 1,
            cliente: ubicacion.cliente,
            distanciaAcumulada: distanciaTotal,
            tiempoAcumulado: tiempoTotal,
            eta: horaETA,
            distanciaTramo: distanciaTramo,
            tiempoTramo: tiempoTramo
        });
        
        // Actualizar posici√≥n actual
        currentLat = ubicacion.lat;
        currentLng = ubicacion.lng;
        
        console.log(`   ${index + 1}. ${ubicacion.cliente} - ETA: ${horaETA} (${distanciaTramo.toFixed(1)} km)`);
    });
    
    // Distancia final a la bodega
    const distanciaFinalBodega = calcularDistancia(currentLat, currentLng, bodegaCoords[0], bodegaCoords[1]);
    const tiempoFinalBodega = (distanciaFinalBodega / config.velocidadPromedio) * 60;
    
    distanciaTotal += distanciaFinalBodega;
    tiempoTotal += tiempoFinalBodega;
    
    // Completar m√©tricas
    metricas.distanciaTotal = distanciaTotal;
    metricas.tiempoTotal = tiempoTotal;
    metricas.tiempoConduccion = tiempoTotal - (ubicacionesOptimizadas.length * config.tiempoPorEntrega);
    metricas.tiempoEntregas = ubicacionesOptimizadas.length * config.tiempoPorEntrega;
    metricas.horaFinEstimada = calcularHoraETA(config.horaInicio, tiempoTotal);
    
    // Generar resumen
    metricas.resumen = `${distanciaTotal.toFixed(1)} km ‚Ä¢ ${Math.round(tiempoTotal)} min`;
    
    console.log(`üìè Distancia total: ${metricas.distanciaTotal.toFixed(1)} km`);
    console.log(`‚è±Ô∏è Tiempo total: ${Math.round(metricas.tiempoTotal)} minutos`);
    console.log(`üèÅ Hora fin estimada: ${metricas.horaFinEstimada}`);
    
    return metricas;
}

// Calcular hora ETA basada en hora de inicio y minutos transcurridos
function calcularHoraETA(horaInicio, minutosTranscurridos) {
    const [hora, minuto] = horaInicio.split(':').map(Number);
    const fechaInicio = new Date();
    fechaInicio.setHours(hora, minuto, 0, 0);
    
    const fechaETA = new Date(fechaInicio.getTime() + minutosTranscurridos * 60000);
    
    return fechaETA.toLocaleTimeString('es-CO', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    });
}

// Mostrar m√©tricas en la interfaz
function mostrarMetricasEnInterfaz(metricas) {
    console.log('üìä Actualizando m√©tricas en interfaz...');
    
    // Buscar o crear contenedor de m√©tricas
    let contenedorMetricas = document.getElementById('metricas-ruta');
    if (!contenedorMetricas) {
        // Crear contenedor si no existe
        contenedorMetricas = document.createElement('div');
        contenedorMetricas.id = 'metricas-ruta';
        contenedorMetricas.className = 'alert alert-info mt-3';
        
        // Insertar despu√©s del bot√≥n de optimizar
        const contenedorBotones = document.querySelector('.optimizer-actions');
        if (contenedorBotones) {
            contenedorBotones.parentNode.insertBefore(contenedorMetricas, contenedorBotones.nextSibling);
        }
    }
    
    // Generar HTML de m√©tricas
    const htmlMetricas = `
        <h5><i class="fas fa-chart-line"></i> M√©tricas de la Ruta</h5>
        <div class="row">
            <div class="col-md-4">
                <div class="metric-card">
                    <div class="metric-number">${metricas.distanciaTotal.toFixed(1)} km</div>
                    <div class="metric-label">Distancia Total</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="metric-card">
                    <div class="metric-number">${Math.round(metricas.tiempoTotal)} min</div>
                    <div class="metric-label">Tiempo Total</div>
                </div>
            </div>
            <div class="col-md-4">
                <div class="metric-card">
                    <div class="metric-number">${metricas.horaFinEstimada}</div>
                    <div class="metric-label">Hora Fin</div>
                </div>
            </div>
        </div>
        <div class="mt-2">
            <small class="text-muted">
                <i class="fas fa-info-circle"></i>
                Conducci√≥n: ${Math.round(metricas.tiempoConduccion)} min ‚Ä¢ 
                Entregas: ${Math.round(metricas.tiempoEntregas)} min ‚Ä¢ 
                Promedio: ${obtenerConfiguracion().velocidadPromedio} km/h
            </small>
        </div>
    `;
    
    contenedorMetricas.innerHTML = htmlMetricas;
    contenedorMetricas.style.display = 'block';
}

// Agregar ETA a cada entrega en la interfaz
function mostrarETAEnEntregas(metricas) {
    console.log('üïê Agregando ETA a entregas...');
    
    metricas.entregas.forEach((entregaMetrica) => {
        // Encontrar el elemento de entrega correspondiente
        const entregaElement = Array.from(document.querySelectorAll('.delivery-item')).find(item => {
            const cliente = item.querySelector('.delivery-client').textContent;
            return cliente === entregaMetrica.cliente;
        });
        
        if (entregaElement) {
            // Buscar o crear contenedor de ETA
            let etaElement = entregaElement.querySelector('.delivery-eta');
            if (!etaElement) {
                etaElement = document.createElement('div');
                etaElement.className = 'delivery-eta';
                
                // Insertar despu√©s de la direcci√≥n del cliente
                const addressElement = entregaElement.querySelector('.delivery-address');
                if (addressElement) {
                    addressElement.parentNode.insertBefore(etaElement, addressElement.nextSibling);
                }
            }
            
            // Actualizar ETA
            etaElement.innerHTML = `
                <small class="text-success">
                    <i class="fas fa-clock"></i> ETA: ${entregaMetrica.eta} 
                    <span class="text-muted">(${entregaMetrica.distanciaAcumulada.toFixed(1)} km)</span>
                </small>
            `;
        }
    });
}

// Mostrar orden optimizado visualmente
function mostrarOrdenOptimizadoVisual(ubicacionesOptimizadas) {
    console.log('üé® Actualizando orden visual...');
    
    const deliveryList = document.getElementById('delivery-list');
    if (!deliveryList) return;
    
    // Reordenar los elementos en el DOM seg√∫n el orden optimizado
    ubicacionesOptimizadas.forEach((ubicacion, index) => {
        const entregaElement = Array.from(document.querySelectorAll('.delivery-item')).find(item => {
            const cliente = item.querySelector('.delivery-client').textContent;
            return cliente === ubicacion.cliente;
        });
        
        if (entregaElement) {
            // Actualizar n√∫mero de orden
            const ordenElement = entregaElement.querySelector('.delivery-order');
            if (ordenElement) {
                ordenElement.textContent = index + 1;
                ordenElement.className = 'orden-optimizado';
            }
            
            // Aplicar estilo de optimizaci√≥n
            entregaElement.classList.add('entrega-optimizada');
            
            // Mover al final de la lista para reordenar
            deliveryList.appendChild(entregaElement);
            
            // Efecto visual
            entregaElement.style.transform = 'scale(1.02)';
            setTimeout(() => {
                entregaElement.style.transform = 'scale(1)';
            }, 200 + index * 100);
        }
    });
    
    mostrarAlerta('success', `Orden optimizado aplicado - Ahorro estimado: 15-30% en tiempo de viaje`);
}

// Wrapper para compatibilidad con botones legacy
function optimizarRuta() {
    return optimizarRutaCompleta();
}

// Extraer coordenadas de un enlace de Google Maps
function extraerCoordenadas(enlaceMaps) {
    try {
        // Buscar patrones comunes de coordenadas en enlaces de Google Maps
        const patterns = [
            /@(-?\d+\.\d+),(-?\d+\.\d+)/, // @lat,lng
            /q=(-?\d+\.\d+),(-?\d+\.\d+)/, // q=lat,lng
            /ll=(-?\d+\.\d+),(-?\d+\.\d+)/, // ll=lat,lng
        ];
        
        for (const pattern of patterns) {
            const match = enlaceMaps.match(pattern);
            if (match) {
                return `${match[1]},${match[2]}`;
            }
        }
        
        // Si no se encuentran coordenadas, usar la URL completa
        return enlaceMaps;
    } catch (error) {
        console.error('Error extrayendo coordenadas:', error);
        return enlaceMaps;
    }
}

// Abrir todas las ubicaciones en Maps
function abrirTodasLasUbicaciones() {
    console.log('üó∫Ô∏è Abriendo todas las ubicaciones');
    
    const entregas = document.querySelectorAll('.delivery-item');
    let contadorAbierto = 0;
    
    entregas.forEach((entrega, index) => {
        const enlaceMaps = entrega.dataset.enlaceMaps;
        const cliente = entrega.querySelector('.delivery-client').textContent;
        
        if (enlaceMaps && enlaceMaps.trim() !== '') {
            // Abrir con un peque√±o delay para evitar bloqueo de popups
            setTimeout(() => {
                window.open(enlaceMaps, '_blank');
            }, index * 500); // 500ms entre cada ventana
            
            contadorAbierto++;
        }
    });
    
    if (contadorAbierto > 0) {
        mostrarAlerta('info', `Abriendo ${contadorAbierto} ubicaciones en Google Maps`);
    } else {
        mostrarAlerta('warning', 'No hay ubicaciones configuradas para abrir');
    }
}

// Simular orden optimizado y mostrar visualmente
function mostrarOrdenOptimizado() {
    console.log('üéØ Simulando orden optimizado de entregas');
    
    const entregas = document.querySelectorAll('.delivery-item');
    
    if (entregas.length === 0) {
        mostrarAlerta('warning', 'No hay entregas para ordenar');
        return;
    }
    
    // Simular algoritmo de optimizaci√≥n 
    const entregasArray = Array.from(entregas);
    
    // Para demostraci√≥n, reordenar por cliente (alfab√©tico) como ejemplo de optimizaci√≥n
    entregasArray.sort((a, b) => {
        const clienteA = a.querySelector('.delivery-client').textContent;
        const clienteB = b.querySelector('.delivery-client').textContent;
        return clienteA.localeCompare(clienteB);
    });
    
    // Aplicar estilos de optimizaci√≥n y reordenar n√∫meros
    entregasArray.forEach((entrega, index) => {
        const ordenElement = entrega.querySelector('.delivery-order');
        
        if (ordenElement) {
            // Actualizar n√∫mero de orden
            ordenElement.textContent = index + 1;
            ordenElement.className = 'orden-optimizado';
        }
        
        // Aplicar estilo de entrega optimizada
        entrega.classList.add('entrega-optimizada');
        
        // Animar la transici√≥n
        entrega.style.transform = 'scale(1.02)';
        setTimeout(() => {
            entrega.style.transform = 'scale(1)';
        }, 200);
    });
    
    // Reordenar elementos en el DOM
    const deliveryList = document.getElementById('delivery-list');
    if (deliveryList) {
        entregasArray.forEach(entrega => {
            deliveryList.appendChild(entrega);
        });
    }
    
    mostrarAlerta('success', `Orden optimizado aplicado a ${entregasArray.length} entregas`);
}

// Mostrar alertas al usuario
function mostrarAlerta(tipo, mensaje) {
    const alertTypes = {
        'success': 'alert-success',
        'error': 'alert-danger',
        'warning': 'alert-warning',
        'info': 'alert-info'
    };
    
    const alertId = 'alert-' + Date.now();
    
    const alertHtml = `
        <div id="${alertId}" class="alert ${alertTypes[tipo]} alert-dismissible fade show" role="alert" style="position: fixed; top: 20px; right: 20px; z-index: 9999; min-width: 300px;">
            <strong>${mensaje}</strong>
            <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span aria-hidden="true">&times;</span>
            </button>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', alertHtml);
    
    // Auto-remover despu√©s de 5 segundos
    setTimeout(() => {
        const alert = document.getElementById(alertId);
        if (alert) {
            alert.remove();
        }
    }, 5000);
}

// Inicializaci√≥n
document.addEventListener('DOMContentLoaded', function() {
    console.log('‚úÖ Sistema de optimizaci√≥n de rutas con estimaci√≥n de tiempos cargado correctamente');
    console.log('üìä Total entregas:', {{ total_entregas }});
    console.log('‚öôÔ∏è Configuraci√≥n inicial:', obtenerConfiguracion());
});

</script>
{% endblock %}